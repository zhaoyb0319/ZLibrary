package cn.zhaoyb.zlibrary.bitmap;import java.io.FileInputStream;import cn.zhaoyb.zlibrary.core.BitmapCallBack;import cn.zhaoyb.zlibrary.core.ZAsyncTask;import cn.zhaoyb.zlibrary.utils.FileUtils;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Handler;import android.os.Looper;/** *  * 本地图片加载 *  * @author zhaoyb (http://www.zhaoyb.cn) * */public class DiskImageRequest {	private BitmapConfig bitmapConfig;	public DiskImageRequest(BitmapConfig bitmapConfig) {		this.bitmapConfig = bitmapConfig;	}    /**     * 根据图片信息加载图片     *      * @param path     * @param maxWidth     * @param maxHeight     * @param callback     */    public void load(String path, int maxWidth, int maxHeight,            BitmapCallBack callback) {		DiskImageRequestTask task = new DiskImageRequestTask(path, maxWidth,				maxHeight, callback);		task.execute();    }    /** 异步图片加载任务 */    class DiskImageRequestTask extends ZAsyncTask<Void, Void, byte[]> {        private String mPath;        private final int mMaxWidth;        private final int mMaxHeight;        private final BitmapCallBack mCallback;        public DiskImageRequestTask(String path, int maxWidth, int maxHeight,                BitmapCallBack callback) {        	this.mPath = path;            mMaxHeight = maxHeight;            mMaxWidth = maxWidth;            mCallback = callback;        }        @Override        protected void onPreExecute() {            super.onPreExecute();            if (mCallback == null) return;            mCallback.onPreStart();        }        @Override        protected byte[] doInBackground(Void... params) {            return loadFromFile(mPath, mMaxWidth, mMaxHeight, mCallback);        }    }    /**     * 从本地载入一张图片     *      * @param path 图片的地址     */    private byte[] loadFromFile(String path, int maxWidth, int maxHeight,            BitmapCallBack callback) {        byte[] data = null;        FileInputStream fis = null;        try {            fis = new FileInputStream(path);            if (fis != null) {                data = FileUtils.input2byte(fis);            }            handleBitmap(path, data, maxWidth, maxHeight, callback);        } catch (Exception e) {            doFailure(callback, e);        } finally {            FileUtils.closeIO(fis);        }        return data;    }    private Bitmap handleBitmap(String path, byte[] data, int maxWidth, int maxHeight,            BitmapCallBack callback) {        BitmapFactory.Options option = new BitmapFactory.Options();        Bitmap bitmap = null;        if (maxWidth == 0 && maxHeight == 0) {            bitmap = BitmapFactory                    .decodeByteArray(data, 0, data.length, option);        } else {            option.inJustDecodeBounds = true;            BitmapFactory.decodeByteArray(data, 0, data.length, option);            int actualWidth = option.outWidth;            int actualHeight = option.outHeight;            // 计算出图片应该显示的宽高            int desiredWidth = BitmapHelper.getResizedDimension(maxWidth, maxHeight,                    actualWidth, actualHeight);            int desiredHeight = BitmapHelper.getResizedDimension(maxHeight, maxWidth,                    actualHeight, actualWidth);            option.inJustDecodeBounds = false;            option.inSampleSize = BitmapHelper.findBestSampleSize(actualWidth, actualHeight,                    desiredWidth, desiredHeight);            Bitmap tempBitmap = BitmapFactory.decodeByteArray(data, 0,                    data.length, option);            // 做缩放            if (tempBitmap != null                    && (tempBitmap.getWidth() > desiredWidth || tempBitmap                            .getHeight() > desiredHeight)) {                bitmap = Bitmap.createScaledBitmap(tempBitmap, desiredWidth,                        desiredHeight, true);                tempBitmap.recycle();            } else {                bitmap = tempBitmap;            }        }        if (bitmap == null) {            doFailure(callback, new RuntimeException("bitmap create error"));        } else {        	bitmapConfig.mMemoryCache.putBitmap(path, bitmap);            doSuccess(callback, bitmap);        }        return bitmap;    }	/** 获取主线程操作句柄*/    private final Handler handle = new Handler(Looper.getMainLooper());    /**     * 图片加载成功时的回调     * @param callback     * @param bitmap     */    private void doSuccess(final BitmapCallBack callback, final Bitmap bitmap) {        if (callback == null) return;        handle.post(new Runnable() {            @Override            public void run() {                callback.onSuccess(bitmap);                callback.onFinish();            }        });    }    /**     * 图片加载失败时的回调     * @param callback     * @param e     */    private void doFailure(final BitmapCallBack callback, final Exception e) {        if (callback == null) return;        handle.post(new Runnable() {            @Override            public void run() {                callback.onFailure(-1, e.getMessage());                callback.onFinish();            }        });    }}